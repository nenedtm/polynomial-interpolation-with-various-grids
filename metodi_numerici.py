# -*- coding: utf-8 -*-
"""metodi_numerici.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EOXvJc94nLiLA6SGXCf2msTt-eCRnZSh

# Interpolazione Polinomiale con griglia di Nodi Equidistanti e griglia di Gauss-Lobatto



* Interpolazione con Nodi Equidistanti:

  I nodi sono distribuiti uniformemente nell'intervallo di interesse.

  Questo metodo è semplice da implementare ma può portare a oscillazioni indesiderate (fenomeno di Runge) per funzioni con variazioni rapide o agli estremi dell'intervallo.

* Interpolazione con Nodi di Gauss-Lobatto:

  I nodi sono scelti in modo non uniforme, concentrandosi maggiormente agli estremi dell'intervallo.

  Questo approccio riduce il fenomeno di Runge e migliora l'accuratezza dell'approssimazione, specialmente per funzioni con comportamenti complessi.
"""

# import librerie utili
import numpy as np
import matplotlib.pyplot as plt
import sympy as sp

"""*   NumPy è una libreria fondamentale per il calcolo scientifico in Python.


*   Matplotlib è una libreria per la creazione di grafici e visualizzazioni



* SymPy è una libreria per il calcolo simbolico in Python, utilizzata per manipolare espressioni matematiche in forma esatta (senza approssimazioni numeriche).

Questa cella di codice permette all’utente di inserire una funzione matematica e specificare i parametri necessari per l’interpolazione (intervallo e grado del polinomio).


Esempi di funzioni che evidenziano le differenze tra le due grigle:

- **Funzione di Runge**: `f(x) = 1 / (1 + 25x²)`   



- **Funzione oscillante**: `f(x) = sin(10x)`
"""

# Input dall'utente
# Funzione per ottenere la funzione da interpolare dall'utente
def get_function_from_user():
    func_str = input("Inserisci la funzione da interpolare (usa 'x' come variabile e funzioni numpy, es: np.sin(x), x**2): ")

    def f(x):
        return eval(func_str)

    return f

# Funzione per ottenere gli estremi dell'intervallo e il grado del polinomio dall'utente
def get_parameters_from_user():
    try:
        a = float(input("Inserisci l'estremo sinistro dell'intervallo (a): "))
        b = float(input("Inserisci l'estremo destro dell'intervallo (b): "))
        n = int(input("Inserisci il grado del polinomio (n): "))
    except ValueError:
        print("Errore: inserisci numeri validi.")
        return get_parameters_from_user()

    return a, b, n

# Richiedi la funzione e i parametri dall'utente
f = get_function_from_user()
a, b, n = get_parameters_from_user()

"""

### Interpolazione di Lagrange

L’interpolazione polinomiale di Lagrange consente di trovare un polinomio $$ P(x) $$ che passa esattamente per un insieme di punti dati $$(x_0, y_0), ..., (x_{n-1}, y_{n-1})$$

Il polinomio è definito come:

$$P(x) = \sum_{i=0}^{n-1} y_i \cdot L_i(x)$$

dove i polinomi di Lagrange $L_i(x)$ sono costruiti in modo che:

$$L_i(x) = \prod_{\substack{j=0 \\ j \ne i}}^{n-1} \frac{x - x_j}{x_i - x_j}$$

Ogni $L_i(x) $ vale 1 in $ x_i $  e 0 in tutti gli altri $ x_j $ con $ j \ne i $, garantendo che $ P(x_i) = y_i $.

"""

# Funzione per costruire il polinomio di Lagrange
def lagrange(x_nodes, y_nodes):
    def interpolator(x):
        total = 0
        n = len(x_nodes)
        for i in range(n):
            xi, yi = x_nodes[i], y_nodes[i]
            term = yi
            for j in range(n):
                if i != j:
                    term *= (x - x_nodes[j]) / (xi - x_nodes[j])
            total += term
        return total
    return interpolator

"""Questa cella definisce una funzione che esegue l’interpolazione polinomiale di Lagrange utilizzando una **griglia equidistante** di nodi."""

# Funzione per interpolare con griglia equidistante usando Lagrange
def interpolate_function_equidistant(f, a, b, n):
    x_nodes = np.linspace(a, b, n + 1)
    y_nodes = f(x_nodes)
    interpolator = lagrange(x_nodes, y_nodes)
    return interpolator, x_nodes, y_nodes

interpolator_eq, x_nodes_eq, y_nodes_eq = interpolate_function_equidistant(f, a, b, n)

print("Interpolazione con griglia uniforme")
print(f"Nodi utilizzati: {len(x_nodes_eq)} punti equidistanti")

"""Questa cella definisce una funzione per calcolare l’**errore di interpolazione**  tra la funzione originale $ f $ e il polinomio interpolante.


"""

# Funzione per calcolare l'errore di interpolazione
def calculate_interpolation_error(f, interpolator, a, b, num_points=1000):
    x_vals = np.linspace(a, b, num_points)
    y_exact = f(x_vals)
    y_interp = interpolator(x_vals)
    error = np.abs(y_exact - y_interp)
    return x_vals, error


x_vals_eq, error_eq = calculate_interpolation_error(f, interpolator_eq, a, b)

print(f"Errore massimo con griglia uniforme: {np.max(error_eq):.6f}")
print(f"Errore medio con griglia uniforme: {np.mean(error_eq):.6f}")

"""Questa cella definisce una funzione che calcola i **nodi di Gauss-Lobatto** nell’intervallo $[a, b]$.

- I nodi sono inizialmente calcolati nell’intervallo standard $[-1, 1]$ usando la formula:  
  $$ x_j = -\cos\left(\frac{\pi j}{n}\right), \quad j=0,\dots,n $$
- Questi nodi includono sempre gli estremi $-1$  e $1$.
- Infine, i nodi vengono trasformati tramite una mappatura affine per adattarli all’intervallo desiderato $[a, b]$:  
  $$ x_j^{[a,b]} = \frac{b - a}{2} x_j + \frac{a + b}{2} $$
  
I nodi di Gauss-Lobatto sono distribuiti non uniformemente, con maggiore densità vicino agli estremi dell’intervallo, risultando molto utili per ridurre errori nelle interpolazioni rispetto a nodi equidistanti.

"""

# Funzione per ottenere i nodi di Gauss-Lobatto su [a, b]
def gauss_lobatto_nodes(a, b, n):
    x_nodes = np.zeros(n + 1)
    for j in range(n + 1):
        # Nodi in [-1, 1]
        xj = -np.cos(np.pi * j / n)
        # Trasformazione affina in [a, b]
        x_nodes[j] = 0.5 * (b - a) * xj + 0.5 * (a + b)
    return x_nodes

"""Questa cella definisce una funzione che esegue l’interpolazione polinomiale di Lagrange utilizzando una **griglia di Gauss-Lobatto**."""

# Interpolazione con griglia di Gauss-Lobatto
def interpolate_function_gauss_lobatto(f, a, b, n):
    x_nodes = gauss_lobatto_nodes(a, b, n)  # Ottieni i nodi mappati direttamente in [a, b]
    y_nodes = f(x_nodes)
    interpolator = lagrange(x_nodes, y_nodes)
    return interpolator, x_nodes, y_nodes

interpolator_gl, x_nodes_gl, y_nodes_gl = interpolate_function_gauss_lobatto(f, a, b, n)

print("Interpolazione con nodi di Gauss-Lobatto")
print(f"Nodi utilizzati: {len(x_nodes_gl)} punti di Gauss-Lobatto")

# errore con griglia di Gauss-Lobatto
# Calcola l'errore per i nodi di Gauss-Lobatto
x_vals_gl, error_gl = calculate_interpolation_error(f, interpolator_gl, a, b)

print(f"Errore massimo con Gauss-Lobatto: {np.max(error_gl):.6f}")
print(f"Errore medio con Gauss-Lobatto: {np.mean(error_gl):.6f}")

plt.figure(figsize=(15, 10))

#Funzione originale e interpolazioni
plt.subplot(2, 2, 1)
x_plot = np.linspace(a, b, 1000)
plt.plot(x_plot, f(x_plot), label='Funzione originale', color='black', linewidth=2)
plt.plot(x_plot, interpolator_gl(x_plot), label='Interpolazione (Gauss-Lobatto)', color='blue', linestyle='--', linewidth=2)
plt.plot(x_plot, interpolator_eq(x_plot), label='Interpolazione (Equidistante)', color='red', linestyle='--', linewidth=2)

plt.scatter(x_nodes_gl, y_nodes_gl, color='blue', zorder=5, s=50, marker='s', label='Nodi Gauss-Lobatto')
plt.scatter(x_nodes_eq, y_nodes_eq, color='red', zorder=5, s=50, marker='o', label='Nodi Equidistanti')

plt.title('Interpolazione polinomiale - Funzione utente')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.grid(True, alpha=0.3)

#Errori
plt.subplot(2, 2, 2)
plt.plot(x_vals_gl, error_gl, color='blue', linestyle='--', linewidth=2, label='Errore (Gauss-Lobatto)')
plt.plot(x_vals_eq, error_eq, color='red', linestyle='--', linewidth=2, label='Errore (Equidistante)')

plt.title('Errore di interpolazione - Funzione utente')
plt.xlabel('x')
plt.ylabel('Errore assoluto')
plt.legend()
plt.grid(True, alpha=0.3)
plt.yscale('log')

"""La costante di Lebesgue $\Lambda_n$ è una misura fondamentale per valutare la stabilità numerica dell'interpolazione polinomiale.


Data una griglia di  $n+1$ nodi distinti $x_0, \dots, x_n$, e i corrispondenti polinomi di Lagrange $\ell_i(x)$ , la costante di Lebesgue è definita come:

$$\Lambda_n = \max_{x \in [a, b]} \sum_{i=0}^n |\ell_i(x)|$$







Se i dati  $f(x_i)$ contengono piccoli errori $\delta_i$, l'errore massimo nell'interpolazione è limitato da:

$$|p_n(x) - \tilde{p}_n(x)\| \leq \Lambda_n \cdot \||\delta\||_\infty\$$



"""

def lebesgue_constant(x_nodes, x_dense):
    n = len(x_nodes)
    S = np.zeros_like(x_dense)
    for i in range(n):
        L = np.ones_like(x_dense)
        for j in range(n):
            if j != i:
                L *= (x_dense - x_nodes[j]) / (x_nodes[i] - x_nodes[j])
        S += np.abs(L)
    return np.max(S)

a, b = -1, 1
x_dense = np.linspace(a, b, 1000)
gradi = range(2, 20)

Λ_eq = []
Λ_gl = []

for n in gradi:
    nodi_eq = np.linspace(a, b, n + 1)
    nodi_gl = gauss_lobatto_nodes(a, b, n)

    Λ_eq.append(lebesgue_constant(nodi_eq, x_dense))
    Λ_gl.append(lebesgue_constant(nodi_gl, x_dense))


#Costante di Lebesgue
plt.subplot(2, 1, 2)
plt.plot(gradi, Λ_eq, 'r-o', label='Griglia equidistante', linewidth=2, markersize=6)
plt.plot(gradi, Λ_gl, 'b-s', label='Griglia Gauss-Lobatto', linewidth=2, markersize=6)
plt.yscale('log')
plt.xlabel("Grado del polinomio (n)")
plt.ylabel("Costante di Lebesgue Λₙ")
plt.title("Confronto della costante di Lebesgue")
plt.grid(True, which='both', linestyle='--', alpha=0.3)
plt.legend()

plt.tight_layout()
plt.show()

"""# Interpolazione con dati sperimentali

Nella sezione precedente abbiamo analizzato l’interpolazione polinomiale assumendo come input una funzione nota, valutando il comportamento dell’approssimazione sia con nodi equidistanti che con nodi di Gauss-Lobatto.

Tuttavia, in molti contesti reali, non disponiamo di una funzione espressa analiticamente, ma solo di un insieme di punti sperimentali: ascisse e corrispondenti ordinate. In questi casi, l’interpolazione polinomiale può comunque essere applicata per stimare l’andamento della grandezza osservata e anche per effettuare estrapolazioni.

Per illustrare questo approccio, considereremo le emissioni globali di anidride carbonica (CO₂) dal 1922 al 2021. (fonti:  https://ourworldindata.org/co2-and-greenhouse-gas-emissions )




Oltre ad analizzare l’accuratezza dell’interpolazione all’interno dell’intervallo dei dati, verrà testata anche la capacità di estrapolazione del modello.

Questa cella di codice permette all’utente di inserire i dati sperimentali e specificare i parametri necessari per l’interpolazione (intervallo e grado del polinomio).
"""

# Funzione per ottenere i dati di ascisse e ordinate dall'utente
def get_data_from_user():
    try:
        x_data = input("Inserisci i valori delle ascisse separati da virgola (es: 1, 2, 3, 4): ")
        y_data = input("Inserisci i valori delle ordinate separati da virgola (es: 2, 4, 6, 8): ")

        x_data = np.array([float(x) for x in x_data.split(',')])
        y_data = np.array([float(y) for y in y_data.split(',')])

        if len(x_data) != len(y_data):
            print("Errore: Il numero di ascisse e ordinate deve essere lo stesso.")
            return get_data_from_user()

    except ValueError:
        print("Errore: Inserisci valori numerici validi.")
        return get_data_from_user()

    return x_data, y_data

x_data, y_data = get_data_from_user()

# Funzione per ottenere il grado del polinomio dall'utente
def get_polynomial_degree_from_user():
    try:
        n = int(input("Inserisci il grado del polinomio (n): "))
    except ValueError:
        print("Errore: inserisci un numero intero valido.")
        return get_polynomial_degree_from_user()
    return n

n = get_polynomial_degree_from_user()

"""Anni: 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996


Emissione di CO2 nei rispettivi anni:
2.1292646, 2.2258415, 2.103328, 2.37238, 2.5092719, 2.4968188, 2.5189998, 2.522121, 2.7107303, 2.829694, 2.8642392, 2.8864362, 2.9810743, 3.1088755, 3.0682025, 3.1172154, 3.2123766, 3.3127992, 3.389065, 3.4821656, 3.5207915, 3.6382928, 3.800649, 4.031552, 4.111967, 4.2195787, 4.357756, 4.257117, 4.1897635, 4.341634, 4.387014, 4.444167, 4.4903517, 4.38398, 4.2029867, 4.094062, 4.0465407, 4.112731, 4.176523, 4.163081, 4.21461, 4.30166, 4.2841187, 4.2799, 4.296785, 4.1085906, 4.087606, 4.0692253, 4.096046, 4.163014

"""

a, b = min(x_data), max(x_data)

"""Questa cella definisce una funzione che esegue l’interpolazione polinomiale di Lagrange utilizzando una **griglia equidistante** di nodi."""

# Funzione per interpolare i dati su una griglia equidistanziata
def interpolate_data_equidistant(x_data, y_data, n):
    x_nodes = np.linspace(a, b, n+1)
    y_nodes = np.interp(x_nodes, x_data, y_data)
    interpolator = lagrange(x_nodes, y_nodes)
    return interpolator, x_nodes, y_nodes

interpolator_eq, x_nodes_eq, y_nodes_eq = interpolate_data_equidistant(x_data, y_data, n)

"""Questa cella definisce una funzione che esegue l’interpolazione polinomiale di Lagrange utilizzando una **griglia di Gauss-Lobatto**."""

# Funzione per interpolare i dati su una griglia di Gauss-Lobatto
def interpolate_data_gauss_lobatto(x_data, y_data, n):
    x_nodes = gauss_lobatto_nodes(a, b, n)
    y_nodes = np.interp(x_nodes, x_data, y_data)
    interpolator = lagrange(x_nodes, y_nodes)
    return interpolator, x_nodes, y_nodes

interpolator_gl, x_nodes_gl, y_nodes_gl = interpolate_data_gauss_lobatto(x_data, y_data, n)

"""Questa cella calcola l'errore nell'interpolazione per le due griglie di nodi."""

def calculate_interpolation_error_on_data(x_data, y_data, interpolator):
    y_interp = interpolator(x_data)
    error = np.abs(y_data - y_interp)
    return x_data, error

# Calcolo dell'errore con griglia equidistanziata sui dati originali
x_vals_eq, error_eq = calculate_interpolation_error_on_data(x_data, y_data, interpolator_eq)
print(f"Errore massimo con griglia equidistante: {np.max(error_eq):.6f}")
print(f"Errore medio con griglia equidistante: {np.mean(error_eq):.6f}")

# Calcolo dell'errore con griglia di Gauss-Lobatto sui dati originali
x_vals_gl, error_gl = calculate_interpolation_error_on_data(x_data, y_data, interpolator_gl)
print(f"Errore massimo con griglia di Gauss-Lobatto: {np.max(error_gl):.6f}")
print(f"Errore medio con griglia di Gauss-Lobatto: {np.mean(error_gl):.6f}")

"""Questa funzione ci permette di visualizzare i polinomi generati sopra"""

def print_poly(x_nodes, y_nodes):
    x = sp.Symbol('x')
    total = 0
    n = len(x_nodes)
    for i in range(n):
        xi, yi = x_nodes[i], y_nodes[i]
        term = yi
        for j in range(n):
            if i != j:
                term *= (x - x_nodes[j]) / (xi - x_nodes[j])
        total += term
    return sp.simplify(total)

poly_eq = print_poly(x_nodes_eq, y_nodes_eq)
print("Polinomio con griglia equidistante:")
print(poly_eq)

poly_gl = print_poly(x_nodes_gl, y_nodes_gl)
print("\nPolinomio con nodi di Gauss-Lobatto:")
print(poly_gl)

# Grafico della funzione e del polinomio interpolante
plt.figure(figsize=(15, 8))

# Dati originali e interpolazioni
plt.subplot(1, 2, 1)
x_plot = np.linspace(a, b, 1000)
y_data_plot = np.interp(x_plot, x_data, y_data)

plt.plot(x_plot, y_data_plot, label='Dati originali (interpolati)', color='black', linewidth=2)
plt.plot(x_plot, interpolator_gl(x_plot), label=f'Interpolazione (Gauss-Lobatto, grado {n})', color='blue', linestyle='--', linewidth=2)
plt.plot(x_plot, interpolator_eq(x_plot), label='Interpolazione (Equidistante)', color='red', linestyle='--', linewidth=2)

plt.scatter(x_nodes_gl, y_nodes_gl, color='blue', zorder=5, s=50, marker='s', label='Nodi Gauss-Lobatto')
plt.scatter(x_nodes_eq, y_nodes_eq, color='red', zorder=5, s=50, marker='o', label='Nodi Equidistanti')

plt.title('Interpolazione polinomiale con Gauss-Lobatto')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.grid(True, alpha=0.3)

#Errori
plt.subplot(1, 2, 2)
plt.plot(x_vals_gl, error_gl, color='blue', linestyle='--', linewidth=2, label='Errore (Gauss-Lobatto)')
plt.plot(x_vals_eq, error_eq, color='red', linestyle='--', linewidth=2, label='Errore (Equidistante)')

plt.title('Errore di interpolazione')
plt.xlabel('x')
plt.ylabel('Errore assoluto')
plt.legend()
plt.grid(True, alpha=0.3)
plt.yscale('log')

plt.tight_layout()
plt.show()

"""
Nei nostri esempi abbiamo costruito polinomi interpolanti su un intervallo $ [a, b]$.  
Ora ci chiediamo: cosa succede se usiamo quei polinomi per valutare $f(x)$ fuori dall’intervallo, cioè in estrapolazione?

L’interpolazione polinomiale è ben definita e controllata dentro $[a, b]$, ma diventa instabile fuori.


Il fenomeno è accentuato per polinomi di grado alto e causa grandi errori di estrapolazione dovuti all'overfitting."""

# Funzione per calcolare l'ordinata di un valore x dato dall'utente
def calculate_value_at_x(interpolator):
    try:
        x_input = float(input("Inserisci un valore di x per calcolare l'ordinata corrispondente: "))
        y_value = interpolator(x_input)
        print(f"L'ordinata corrispondente per x = {x_input} è y = {y_value:.4f}")
    except ValueError:
        print("Errore: inserisci un numero valido per x.")
        calculate_value_at_x(interpolator)

# Esegui la funzione per ottenere l'ordinata di un valore specifico di x
print("\nCalcolo dell'ordinata con griglia equidistante")
calculate_value_at_x(interpolator_eq)

print("\nCalcolo dell'ordinata con griglia di Gauss-Lobatto")
calculate_value_at_x(interpolator_gl)

"""Più mi allontano dall'intervallo $[a,b]$ più sarà facile avere errori grandi


|Anno| Emissioni di CO2|
|----|-----------------|
|1922|1.683432|
|1927| 1.9864538|
|1940| 2.122051
|1945|1.7885866
|1997| 4.13037|
|2002|     4.1582055            |
|2015|        4.775163         |
|2021|    4.654845             |

Nel grafico seguente confrontiamo l’errore di interpolazione fuori da $[a, b]$ per le due griglie:
- Nodi equidistanti
- Nodi di Gauss-Lobatto

I polinomi usati sono gli stessi che abbiamo già costruito.
"""

# Estendiamo l’intervallo
x_true =  [1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,
    1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,
    1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,
    1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,
    2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021]
y_true = [1.683432,1.893368,1.8824672,1.8860849,1.8362813,1.9864538,1.9602886,2.084881,1.9021566,1.6854303,
    1.5044751,1.5680304,1.6880137,1.7537812,1.9043846,2.014623,1.8747287,1.9639443,2.122051,2.153978,
    2.1315649,2.15036,2.1663656,1.7885866,1.9376519,2.1292646,2.2258415,2.103328,2.37238,2.5092719,
    2.4968188,2.5189998,2.522121,2.7107303,2.829694,2.8642392,2.8864362,2.9810743,3.1088755,3.0682025,
    3.1172154,3.2123766,3.3127992,3.389065,3.4821656,3.5207915,3.6382928,3.800649,4.031552,4.111967,
    4.2195787,4.357756,4.257117,4.1897635,4.341634,4.387014,4.444167,4.4903517,4.38398,4.2029867,
    4.094062,4.0465407,4.112731,4.176523,4.163081,4.21461,4.30166,4.2841187,4.2799,4.296785,4.1085906,
    4.087606,4.0692253,4.096046,4.163014,4.13037,4.0637503,4.0926967,4.147293,4.1206822,4.1582055,
    4.324224,4.4195943,4.5122457,4.6083193,4.683315,4.704022,4.565362,4.7678533,4.8686357,4.878096,
    4.8592534,4.8325562,4.775163,4.719525,4.740302,4.7850013,4.770166,4.4647303,4.654845]




est_a = min(x_true)
est_b = max(x_true)


# Interpolazione con nodi equidistanti
y_eq = interpolator_eq(x_true)
err_eq = np.abs(y_true - y_eq)

# Interpolazione con nodi Gauss-Lobatto
y_gl = interpolator_gl(x_true)
err_gl = np.abs(y_true - y_gl)


plt.figure(figsize=(10, 5))
plt.plot(x_true, err_eq, 'r-', label='Errore (equi)', linewidth=2)
plt.plot(x_true, err_gl, 'b-', label='Errore (Gauss-Lobatto)', linewidth=2)
plt.axvline(a, color='gray', linestyle='--', linewidth=1)
plt.axvline(b, color='gray', linestyle='--', linewidth=1)
plt.title("Errore di interpolazione dentro e fuori da [a, b]")
plt.xlabel("x")
plt.ylabel("Errore |f(x) - p(x)|")
plt.yscale('log')
plt.grid(True, which='both', ls='--', alpha=0.4)
plt.legend()
plt.show()